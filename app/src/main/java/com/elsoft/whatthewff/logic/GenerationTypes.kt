package com.elsoft.whatthewff.logic

import com.elsoft.whatthewff.logic.AvailableTiles.and
import com.elsoft.whatthewff.logic.AvailableTiles.iff
import com.elsoft.whatthewff.logic.AvailableTiles.implies
import com.elsoft.whatthewff.logic.AvailableTiles.or

/**
 * Represents a single step in a generated proof, linking a formula to its justification.
 */
data class ProofStep(val formula: Formula, val justification: String, val premises: List<Formula>)

/**
 * A data class to bundle a forward-acting generation strategy.
 */
data class ForwardRule(
    val name: String,
    val canApply: (knownFormulas: List<Formula>) -> Boolean,
    val generate: (knownFormulas: List<Formula>) -> ProofStep?
)

/**
 * Represents the output of one backward step of generation.
 * @property newPremises A list of new premises generated by the generation strategy.
 *           This is a list of formulas that are "finished." We add them directly to the
 *           final list of premises that the user will see.
 * @property nextGoals A list of potential next goals to continue the generation.
 *           This is a list of formulas that are not finished. We add them back into
 *           the goalsToSolve queue to be broken down further in subsequent steps of the generation.
 */
data class GenerationStep(val newPremises: List<Formula>, val nextGoals: List<Formula>)

/**
 * A data class to bundle a generation strategy with its applicability check.
 * @property canApply A function that takes a goal formula and returns a boolean.
 *           If this function returns true, then the generation strategy can be applied to the goal.
 *           If it returns false, then the generation strategy cannot be applied.
 * @property generate A function that takes a goal formula and a list of available variables.
 *           It returns a nullable GenerationStep object, which contains the new premises and
 *           next goals.  If the generation strategy cannot be applied to the goal, this function
 *           returns null.  This might happen, for example, if there are not enough available
 *           variables to generate the next goal.
 */
data class GenerationStrategy(
    val name: String,
    val canApply: (goal: Formula) -> Boolean,
    val generate: (goal: Formula, availableVars: MutableList<LogicTile>) -> GenerationStep?
)

/**
 * Converts a FormulaNode to a Formula.
 */
fun treeToFormula(node: FormulaNode): Formula {
    val tiles = mutableListOf<LogicTile>()

    fun getPrecedence(op: LogicTile?): Int {
        return when (op) {
            iff -> 1
            implies -> 2
            or -> 3
            and -> 4
            else -> 0 // Handles null or any other tile (or null)
        }
    }

    fun build(node: FormulaNode, parentPrecedence: Int, isRightChild: Boolean) {
        when (node) {
            is FormulaNode.VariableNode -> tiles.add(node.tile)
            is FormulaNode.UnaryOpNode -> {
                tiles.add(node.operator)
                build(node.child, 10, false) // High precedence for unary content
            }
            is FormulaNode.BinaryOpNode -> {
                val currentPrecedence = getPrecedence(node.operator)
                // Parenthesize if the current operator has lower precedence than its parent,
                // or if it's the same precedence and on the right side of a left-associative op.
                val needsParens = currentPrecedence < parentPrecedence ||
                        (currentPrecedence == parentPrecedence && isRightChild && node.operator != implies)

                if (needsParens) tiles.add(AvailableTiles.leftParen)

                build(node.left, currentPrecedence, false)
                tiles.add(node.operator)
                build(node.right, currentPrecedence, true)

                if (needsParens) tiles.add(AvailableTiles.rightParen)
            }
        }
    }

    build(node, 0, false)
    return Formula(tiles)
}
