// File: logic/RuleReplacer.kt
// This file contains the logic for applying replacement rules to a formula's syntax tree.

package com.elsoft.whatthewff.logic

import com.elsoft.whatthewff.logic.AvailableTiles.or
import com.elsoft.whatthewff.logic.AvailableTiles.and
import com.elsoft.whatthewff.logic.AvailableTiles.implies
import com.elsoft.whatthewff.logic.AvailableTiles.leftParen
import com.elsoft.whatthewff.logic.AvailableTiles.not
import com.elsoft.whatthewff.logic.AvailableTiles.rightParen
import com.elsoft.whatthewff.logic.ForwardRuleGenerators.treeToFormula

//import com.elsoft.whatthewff.logic.AvailableTiles.implies
//import com.elsoft.whatthewff.logic.AvailableTiles.iff
//import com.elsoft.whatthewff.logic.AvailableTiles.leftParen
//import com.elsoft.whatthewff.logic.AvailableTiles.rightParen


object ReplacementStrategies {

    val deMorgans = GenerationStrategy(
        /**
         * DeMorgan's Theorem:
         * Rule 1: ¬(P ∧ Q) ⇔ (¬P ∨ ¬Q)
         * Rule 2: ¬(P ∨ Q) ⇔ (¬P ∧ ¬Q)
         */
        name = "DeMorgan's Theorem",
        canApply = { goal ->
            // Commutation can apply if the goal is a conjunction or disjunction.
            WffParser.parse(goal)?.let {
                (it is FormulaNode.UnaryOpNode && it.operator == not &&
                        it.child is FormulaNode.BinaryOpNode &&
                        it.child.operator != implies) ||
                (it is FormulaNode.BinaryOpNode && it.operator == or &&
                        it.left is FormulaNode.UnaryOpNode && it.left.operator == not &&
                        it.right is FormulaNode.UnaryOpNode && it.right.operator == not)
            } ?: false
        },
        generate = { goal, _ ->
            WffParser.parse(goal)?.let { rootNode ->
                // Use the existing RuleReplacer logic.
                val possibleTrees = RuleReplacer.apply(ReplacementRule.DEMORGANS_THEOREM, rootNode)

                // Convert the resulting trees back to Formulas.
                val nextGoals = possibleTrees.map { treeToFormula(it) }

                // A replacement rule creates new goals, not new premises.
                GenerationStep(newPremises = emptyList(), nextGoals = nextGoals)
            }
        }
    )

    val commutation = GenerationStrategy(
        name = "Commutation",
        canApply = { goal ->
            // Commutation can apply if the goal is a conjunction or disjunction.
            WffParser.parse(goal)?.let {
                it is FormulaNode.BinaryOpNode && (it.operator == and || it.operator == or)
            } ?: false
        },
        generate = { goal, _ ->
            WffParser.parse(goal)?.let { rootNode ->
                // Use the existing RuleReplacer logic.
                val possibleTrees = RuleReplacer.apply(ReplacementRule.COMMUTATION, rootNode)

                // Convert the resulting trees back to Formulas.
                val nextGoals = possibleTrees.map { treeToFormula(it) }

                // A replacement rule creates new goals, not new premises.
                GenerationStep(newPremises = emptyList(), nextGoals = nextGoals)
            }
        }
    )

    val allStrategies = listOf(
        deMorgans,
        commutation,
    )

}


/**
 * A singleton object that handles the application of replacement rules.
 */
object RuleReplacer {
    /**
     * The main public function. It takes a syntax tree and a rule, and returns a list
     * of all possible new trees that can be generated by applying the rule at any
     * valid point within the original tree.
     *
     * @param rule The replacement rule to apply.
     * @param rootNode The root of the formula syntax tree to transform.
     * @return A list of new FormulaNode trees, each representing a valid transformation.
     */
    fun apply(rule: ReplacementRule, rootNode: FormulaNode): List<FormulaNode> {
        return when (rule) {
            ReplacementRule.DEMORGANS_THEOREM -> applyDeMorgans(rootNode)
            ReplacementRule.COMMUTATION -> applyCommutation(rootNode)
            ReplacementRule.ASSOCIATION -> TODO()
            ReplacementRule.DISTRIBUTION -> TODO()
            ReplacementRule.DOUBLE_NEGATION -> TODO()
            ReplacementRule.TRANSPOSITION -> TODO()
            ReplacementRule.MATERIAL_IMPLICATION -> TODO()
            ReplacementRule.MATERIAL_EQUIVALENCE -> TODO()
            ReplacementRule.EXPORTATION -> TODO()
            ReplacementRule.TAUTOLOGY -> TODO()
        }
    }

    /**
     * A helper function that intelligently negates a given formula tree.
     * It correctly handles double negation (¬¬P -> P).
     */
    private fun negate(node: FormulaNode): FormulaNode {
        // If the node is already a negation, return its child (Double Negation).
        if (node is FormulaNode.UnaryOpNode && node.operator == not) {
            return node.child
        }
        // Otherwise, wrap the node in a new negation.
        return FormulaNode.UnaryOpNode(AvailableTiles.not, node)
    }

    //----------------------- Replacement Implementations ---------------------------

    /**
     * Recursively applies DeMorgan's Theorem to a given node and all its children.
     * Rule 1: ¬(P ∧ Q) ⇔ (¬P ∨ ¬Q)
     * Rule 2: ¬(P ∨ Q) ⇔ (¬P ∧ ¬Q)
     */
    private fun applyDeMorgans(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()

        // 1. Apply the rule at the CURRENT node, if possible.

        // Form 1: ¬(P op Q) -> (¬P inv_op ¬Q)
        if (node is FormulaNode.UnaryOpNode && node.operator == not &&
            node.child is FormulaNode.BinaryOpNode) {
            val innerNode = node.child as FormulaNode.BinaryOpNode
            if (innerNode.operator == and || innerNode.operator == or) {
                val p = innerNode.left
                val q = innerNode.right
                val inverseOp = if (innerNode.operator == and) AvailableTiles.or else AvailableTiles.and

                val notP = negate(p)
                val notQ = negate(q)

                possibleNewTrees.add(FormulaNode.BinaryOpNode(inverseOp, notP, notQ))
            }
        }

        // Form 2: (P op Q) -> ¬(¬P inv_op ¬Q)
        if (node is FormulaNode.BinaryOpNode && (node.operator == and || node.operator == or)) {
            val p = node.left
            val q = node.right
            val inverseOp = if (node.operator == or) AvailableTiles.or else AvailableTiles.and

            val notP = negate(p)
            val notQ = negate(q)

            val innerNode = FormulaNode.BinaryOpNode(inverseOp, notP, notQ)
            possibleNewTrees.add(FormulaNode.UnaryOpNode(AvailableTiles.not, innerNode))
        }

        // 2. Recursively apply the rule to all CHILDREN nodes.
        when (node) {
            is FormulaNode.UnaryOpNode -> {
                applyDeMorgans(node.child).forEach { transformedChild ->
                    possibleNewTrees.add(node.copy(child = transformedChild))
                }
            }
            is FormulaNode.BinaryOpNode -> {
                applyDeMorgans(node.left).forEach { transformedLeft ->
                    possibleNewTrees.add(node.copy(left = transformedLeft))
                }
                applyDeMorgans(node.right).forEach { transformedRight ->
                    possibleNewTrees.add(node.copy(right = transformedRight))
                }
            }
            is FormulaNode.VariableNode -> { /* No children */ }
        }

        return possibleNewTrees
    }

    /**
     * Recursively applies the Commutation rule to a given node and all its children.
     * Commutation: (P ∧ Q) ⇔ (Q ∧ P)  and  (P ∨ Q) ⇔ (Q ∨ P)
     */
    private fun applyCommutation(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()

        // 1. Apply the rule at the CURRENT node, if possible.
        if (node is FormulaNode.BinaryOpNode &&
            (node.operator == and || node.operator == or)) {
            // Create the commuted version of this node by swapping left and right children.
            val commutedNode = node.copy(left = node.right, right = node.left)
            possibleNewTrees.add(commutedNode)
        }

        // 2. Recursively apply the rule to all CHILDREN nodes and
        //    rebuild the current node.  This is the key here.  We are
        //    iteratively building all the possible permutations of the
        //    parent node with all the possible permutations of the
        //    child nodes.
        when (node) {
            is FormulaNode.UnaryOpNode -> {
                // Get all possible transformations of the child.
                val childTransforms = applyCommutation(node.child)
                // For each transformed child, create a new version of the parent UnaryOpNode.
                childTransforms.forEach { txChild ->
                    possibleNewTrees.add(node.copy(child = txChild))
                }
            }
            is FormulaNode.BinaryOpNode -> {
                // Rebuild the node by recursively applying the rule to both children,
                // then hold one side the same as the original and create new possible
                // nodes with all the possible transformations of the other side.

                // Get all possible transformations of the left child.
                // Keep the right child the same as the original.
                applyCommutation(node.left).forEach { txLeft ->
                    possibleNewTrees.add(node.copy(left = txLeft))
                }

                // Get all possible transformations of the right child.
                // Keep the left child the same as the original.
                applyCommutation(node.right).forEach { txRight ->
                    possibleNewTrees.add(node.copy(right = txRight))
                }
            }
            is FormulaNode.VariableNode -> {
                // A variable has no children, so do nothing.
            }
        }

        return possibleNewTrees
    }
}
