// File: logic/RuleReplacer.kt
// This file contains the logic for applying replacement rules to a formula's syntax tree.

package com.elsoft.whatthewff.logic

import com.elsoft.whatthewff.logic.AvailableTiles.or
import com.elsoft.whatthewff.logic.AvailableTiles.and
import com.elsoft.whatthewff.logic.AvailableTiles.iff
import com.elsoft.whatthewff.logic.AvailableTiles.implies
import com.elsoft.whatthewff.logic.AvailableTiles.not
import com.elsoft.whatthewff.logic.RuleGenerators.treeToFormula

//import com.elsoft.whatthewff.logic.AvailableTiles.implies
//import com.elsoft.whatthewff.logic.AvailableTiles.iff
//import com.elsoft.whatthewff.logic.AvailableTiles.leftParen
//import com.elsoft.whatthewff.logic.AvailableTiles.rightParen


object ReplacementStrategies {

    val deMorgans = GenerationStrategy(
        /**
         * DeMorgan's Theorem:
         * Rule 1: ¬(P ∧ Q) ⇔ (¬P ∨ ¬Q)
         * Rule 2: ¬(P ∨ Q) ⇔ (¬P ∧ ¬Q)
         */
        name = "DeMorgan's Theorem",
        canApply = { goal ->
            // Commutation can apply if the goal is a conjunction or disjunction.
            WffParser.parse(goal)?.let {
                (it is FormulaNode.UnaryOpNode && it.operator == not &&
                        it.child is FormulaNode.BinaryOpNode &&
                        it.child.operator != implies) ||
                (it is FormulaNode.BinaryOpNode && it.operator == or &&
                        it.left is FormulaNode.UnaryOpNode && it.left.operator == not &&
                        it.right is FormulaNode.UnaryOpNode && it.right.operator == not)
            } ?: false
        },
        generate = { goal, _ ->
            WffParser.parse(goal)?.let { rootNode ->
                // Use the existing RuleReplacer logic.
                val possibleTrees = RuleReplacer.apply(ReplacementRule.DEMORGANS_THEOREM, rootNode)

                // Convert the resulting trees back to Formulas.
                val nextGoals = possibleTrees.map { treeToFormula(it) }

                // A replacement rule creates new goals, not new premises.
                GenerationStep(newPremises = emptyList(), nextGoals = nextGoals)
            }
        }
    )

    val commutation = GenerationStrategy(
        name = "Commutation",
        canApply = { goal ->
            // Commutation can apply if the goal is a conjunction or disjunction.
            WffParser.parse(goal)?.let {
                it is FormulaNode.BinaryOpNode && (it.operator == and || it.operator == or)
            } ?: false
        },
        generate = { goal, _ ->
            WffParser.parse(goal)?.let { rootNode ->
                // Use the existing RuleReplacer logic.
                val possibleTrees = RuleReplacer.apply(ReplacementRule.COMMUTATION, rootNode)

                // Convert the resulting trees back to Formulas.
                val nextGoals = possibleTrees.map { treeToFormula(it) }

                // A replacement rule creates new goals, not new premises.
                GenerationStep(newPremises = emptyList(), nextGoals = nextGoals)
            }
        }
    )

    val allStrategies = listOf(
        deMorgans,
        commutation,
    )

}

/**
 * A singleton object that handles the application of replacement rules.
 */
object RuleReplacer {
    /**
     * The main public function. It takes a syntax tree and a rule, and returns a list
     * of all possible new trees that can be generated by applying the rule at any
     * valid point within the original tree.
     *
     * @param rule The replacement rule to apply.
     * @param rootNode The root of the formula syntax tree to transform.
     * @return A list of new FormulaNode trees, each representing a valid transformation.
     */
    fun apply(rule: ReplacementRule, rootNode: FormulaNode): List<FormulaNode> {
        return when (rule) {
            ReplacementRule.DEMORGANS_THEOREM -> applyDeMorgans(rootNode)
            ReplacementRule.COMMUTATION -> applyCommutation(rootNode)
            ReplacementRule.ASSOCIATION -> applyAssociation(rootNode)
            ReplacementRule.DISTRIBUTION -> applyDistribution(rootNode)
            ReplacementRule.DOUBLE_NEGATION -> applyDoubleNegation(rootNode)
            ReplacementRule.TRANSPOSITION -> applyTransposition(rootNode)
            ReplacementRule.MATERIAL_IMPLICATION -> applyMaterialImplication(rootNode)
            ReplacementRule.MATERIAL_EQUIVALENCE -> applyMaterialEquivalence(rootNode)
            ReplacementRule.EXPORTATION -> applyExportation(rootNode)
            ReplacementRule.TAUTOLOGY -> applyTautology(rootNode)
        }
    }

    /**
     * A helper function that intelligently negates a given formula tree.
     * It correctly handles double negation (¬¬P -> P).
     */
    private fun negate(node: FormulaNode): FormulaNode {
        // If the node is already a negation, return its child (Double Negation).
        if (node is FormulaNode.UnaryOpNode && node.operator == not) {
            return node.child
        }
        // Otherwise, wrap the node in a new negation.
        return FormulaNode.UnaryOpNode(AvailableTiles.not, node)
    }

    //----------------------- Replacement Implementations ---------------------------

    private fun applyAssociation(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // Form 1: (P op (Q op R)) -> ((P op Q) op R)
        if (node is FormulaNode.BinaryOpNode && (node.operator == or || node.operator == and)) {
            if (node.right is FormulaNode.BinaryOpNode && node.operator == (node.right as FormulaNode.BinaryOpNode).operator) {
                val p = node.left
                val q = (node.right as FormulaNode.BinaryOpNode).left
                val r = (node.right as FormulaNode.BinaryOpNode).right
                possibleNewTrees.add(FormulaNode.BinaryOpNode(node.operator, FormulaNode.BinaryOpNode(node.operator, p, q), r))
            }
        }
        // Form 2: ((P op Q) op R) -> (P op (Q op R))
        if (node is FormulaNode.BinaryOpNode && (node.operator == or || node.operator == and)) {
            if (node.left is FormulaNode.BinaryOpNode && node.operator == (node.left as FormulaNode.BinaryOpNode).operator) {
                val p = (node.left as FormulaNode.BinaryOpNode).left
                val q = (node.left as FormulaNode.BinaryOpNode).right
                val r = node.right
                possibleNewTrees.add(FormulaNode.BinaryOpNode(node.operator, p, FormulaNode.BinaryOpNode(node.operator, q, r)))
            }
        }
        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyAssociation(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyAssociation(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.UnaryOpNode -> applyAssociation(node.child).forEach { possibleNewTrees.add(node.copy(child = it)) }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }

    /**
     * Recursively applies the Commutation rule to a given node and all its children.
     * Commutation: (P ∧ Q) ⇔ (Q ∧ P)  and  (P ∨ Q) ⇔ (Q ∨ P)
     */
    private fun applyCommutation(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()

        // 1. Apply the rule at the CURRENT node, if possible.
        if (node is FormulaNode.BinaryOpNode &&
            (node.operator == and || node.operator == or)) {
            // Create the commuted version of this node by swapping left and right children.
            val commutedNode = node.copy(left = node.right, right = node.left)
            possibleNewTrees.add(commutedNode)
        }

        // 2. Recursively apply the rule to all CHILDREN nodes and
        //    rebuild the current node.  This is the key here.  We are
        //    iteratively building all the possible permutations of the
        //    parent node with all the possible permutations of the
        //    child nodes.
        when (node) {
            is FormulaNode.UnaryOpNode -> {
                // Get all possible transformations of the child.
                // For each transformed child, create a new version of the parent UnaryOpNode.
                applyCommutation(node.child)
                    .forEach { txChild ->
                        possibleNewTrees.add(node.copy(child = txChild))
                    }
            }
            is FormulaNode.BinaryOpNode -> {
                // Rebuild the node by recursively applying the rule to both children,
                // then hold one side the same as the original and create new possible
                // nodes with all the possible transformations of the other side.

                // Get all possible transformations of the left child.
                // Keep the right child the same as the original.
                applyCommutation(node.left)
                    .forEach { txLeft ->
                        possibleNewTrees.add(node.copy(left = txLeft))
                    }

                // Get all possible transformations of the right child.
                // Keep the left child the same as the original.
                applyCommutation(node.right)
                    .forEach { txRight ->
                        possibleNewTrees.add(node.copy(right = txRight))
                    }
            }
            // A variable has no children, so do nothing if not one of the above
            is FormulaNode.VariableNode -> {}
        }

        return possibleNewTrees
    }

    /**
     * Recursively applies DeMorgan's Theorem to a given node and all its children.
     * Rule 1: ¬(P ∧ Q) ⇔ (¬P ∨ ¬Q)
     * Rule 2: ¬(P ∨ Q) ⇔ (¬P ∧ ¬Q)
     */
    private fun applyDeMorgans(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // The inverse of the operator
        val invOp = { op: LogicTile -> if (op == and) or else and }

        // 1. Apply the rule at the CURRENT node, if possible.

        // Form 1: ¬(P op Q) -> (¬P inv_op ¬Q)
        if (node is FormulaNode.UnaryOpNode && node.operator == not && node.child is FormulaNode.BinaryOpNode) {
            val child = node.child as FormulaNode.BinaryOpNode
            if (child.operator == and || child.operator == or) {
                possibleNewTrees.add(
                    FormulaNode.BinaryOpNode(
                        invOp(child.operator),
                        negate(child.left),
                        negate(child.right)
                    )
                )
            }
        }

        // Form 2: (P op Q) -> ¬(¬P inv_op ¬Q)
        if (node is FormulaNode.BinaryOpNode && (node.operator == and || node.operator == or)) {
            possibleNewTrees.add(
                negate(
                    FormulaNode.BinaryOpNode(
                        invOp(node.operator),
                        negate(node.left),
                        negate(node.right)
                    )
                )
            )
        }

        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyDeMorgans(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyDeMorgans(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.UnaryOpNode -> applyDeMorgans(node.child)
                                            .forEach { possibleNewTrees.add(node.copy(child = it)) }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }

    private fun applyDistribution(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // Form 1: (P & (Q v R)) -> ((P & Q) v (P & R))
        if (node is FormulaNode.BinaryOpNode && node.operator == and &&
            node.right is FormulaNode.BinaryOpNode && (node.right as FormulaNode.BinaryOpNode).operator == or) {
            val p = node.left
            val q = (node.right as FormulaNode.BinaryOpNode).left
            val r = (node.right as FormulaNode.BinaryOpNode).right
            possibleNewTrees.add(
                FormulaNode.BinaryOpNode(or,
                                         FormulaNode.BinaryOpNode(and, p, q),
                                         FormulaNode.BinaryOpNode(and, p, r)
                )
            )
        }
        // Form 2: ((P & Q) v (P & R)) -> (P & (Q v R))
        if (node is FormulaNode.BinaryOpNode && node.operator == or &&
            node.left is FormulaNode.BinaryOpNode && (node.left as FormulaNode.BinaryOpNode).operator == and &&
            node.right is FormulaNode.BinaryOpNode && (node.right as FormulaNode.BinaryOpNode).operator == and) {
            val p1 = (node.left as FormulaNode.BinaryOpNode).left
            val q = (node.left as FormulaNode.BinaryOpNode).right
            val p2 = (node.right as FormulaNode.BinaryOpNode).left
            val r = (node.right as FormulaNode.BinaryOpNode).right
            if (p1 == p2) {
                possibleNewTrees.add(FormulaNode.BinaryOpNode(and, p1, FormulaNode.BinaryOpNode(or, q, r)))
            }
        }
        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyDistribution(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyDistribution(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.UnaryOpNode -> applyDistribution(node.child).forEach { possibleNewTrees.add(node.copy(child = it)) }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }

    /**
     * Recursively applies the Double Negation rule to a given node and all its children.
     */
    private fun applyDoubleNegation(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // Form 1: A -> ~~A
        possibleNewTrees.add(negate(negate(node)))
        // Form 2: ~~A -> A
        if (node is FormulaNode.UnaryOpNode && node.operator == not &&
            node.child is FormulaNode.UnaryOpNode && (node.child as FormulaNode.UnaryOpNode).operator == not
        ) {
            possibleNewTrees.add((node.child as FormulaNode.UnaryOpNode).child)
        }
        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyDoubleNegation(node.left).forEach { transformedLeft ->
                    possibleNewTrees.add(node.copy(left = transformedLeft))
                }
                applyDoubleNegation(node.right).forEach { transformedRight ->
                    possibleNewTrees.add(node.copy(right = transformedRight))
                }
            }
            is FormulaNode.UnaryOpNode -> {
                applyDoubleNegation(node.child).forEach { transformedChild ->
                    possibleNewTrees.add(node.copy(child = transformedChild))
                }
            }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }

    private fun applyExportation(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // Form 1: ((P & Q) -> R) -> (P -> (Q -> R))
        if (node is FormulaNode.BinaryOpNode && node.operator == implies &&
            node.left is FormulaNode.BinaryOpNode && (node.left as FormulaNode.BinaryOpNode).operator == and) {
            val p = (node.left as FormulaNode.BinaryOpNode).left
            val q = (node.left as FormulaNode.BinaryOpNode).right
            val r = node.right
            possibleNewTrees.add(FormulaNode.BinaryOpNode(implies, p, FormulaNode.BinaryOpNode(implies, q, r)))
        }
        // Form 2: (P -> (Q -> R)) -> ((P & Q) -> R)
        if (node is FormulaNode.BinaryOpNode && node.operator == implies &&
            node.right is FormulaNode.BinaryOpNode && (node.right as FormulaNode.BinaryOpNode).operator == implies) {
            val p = node.left
            val q = (node.right as FormulaNode.BinaryOpNode).left
            val r = (node.right as FormulaNode.BinaryOpNode).right
            possibleNewTrees.add(FormulaNode.BinaryOpNode(implies, FormulaNode.BinaryOpNode(and, p, q), r))
        }
        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyExportation(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyExportation(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.UnaryOpNode -> applyExportation(node.child).forEach { possibleNewTrees.add(node.copy(child = it)) }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }

    private fun applyMaterialEquivalence(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // Form 1: (P <-> Q) -> ((P -> Q) & (Q -> P))
        if (node is FormulaNode.BinaryOpNode && node.operator == iff) {
            val p = node.left
            val q = node.right
            possibleNewTrees.add(
                FormulaNode.BinaryOpNode(and,
                                         FormulaNode.BinaryOpNode(implies, p, q),
                                         FormulaNode.BinaryOpNode(implies, q, p)
                )
            )
        }
        // Form 2: ((P -> Q) & (Q -> P)) -> (P <-> Q)
        if (node is FormulaNode.BinaryOpNode && node.operator == and &&
            node.left is FormulaNode.BinaryOpNode && (node.left as FormulaNode.BinaryOpNode).operator == implies &&
            node.right is FormulaNode.BinaryOpNode && (node.right as FormulaNode.BinaryOpNode).operator == implies) {
            val imp1 = node.left as FormulaNode.BinaryOpNode
            val imp2 = node.right as FormulaNode.BinaryOpNode
            if (imp1.left == imp2.right && imp1.right == imp2.left) {
                possibleNewTrees.add(FormulaNode.BinaryOpNode(iff, imp1.left, imp1.right))
            }
        }
        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyMaterialEquivalence(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyMaterialEquivalence(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.UnaryOpNode -> applyMaterialEquivalence(node.child).forEach { possibleNewTrees.add(node.copy(child = it)) }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }

    private fun applyMaterialImplication(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // Form 1: (P -> Q) -> (~P v Q)
        if (node is FormulaNode.BinaryOpNode && node.operator == implies) {
            possibleNewTrees.add(FormulaNode.BinaryOpNode(or, negate(node.left), node.right))
        }
        // Form 2: (~P v Q) -> (P -> Q)
        if (node is FormulaNode.BinaryOpNode && node.operator == or && node.left is FormulaNode.UnaryOpNode) {
            val p = (node.left as FormulaNode.UnaryOpNode).child
            val q = node.right
            possibleNewTrees.add(FormulaNode.BinaryOpNode(implies, p, q))
        }
        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyMaterialImplication(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyMaterialImplication(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.UnaryOpNode -> applyMaterialImplication(node.child).forEach { possibleNewTrees.add(node.copy(child = it)) }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }

    private fun applyTautology(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // Form 1: P -> (P v P)
        possibleNewTrees.add(FormulaNode.BinaryOpNode(or, node, node))
        // Form 2: P -> (P & P)
        possibleNewTrees.add(FormulaNode.BinaryOpNode(and, node, node))
        // Form 3: (P v P) -> P
        if (node is FormulaNode.BinaryOpNode && node.operator == or && node.left == node.right) {
            possibleNewTrees.add(node.left)
        }
        // Form 4: (P & P) -> P
        if (node is FormulaNode.BinaryOpNode && node.operator == and && node.left == node.right) {
            possibleNewTrees.add(node.left)
        }
        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyTautology(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyTautology(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.UnaryOpNode -> applyTautology(node.child).forEach { possibleNewTrees.add(node.copy(child = it)) }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }

    private fun applyTransposition(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()
        // (P -> Q) <-> (~Q -> ~P)
        if (node is FormulaNode.BinaryOpNode && node.operator == implies) {
            possibleNewTrees.add(
                FormulaNode.BinaryOpNode(
                    implies,
                    negate(node.right),
                    negate(node.left)
                )
            )
        }
        // Recurse
        when (node) {
            is FormulaNode.BinaryOpNode -> {
                applyTransposition(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyTransposition(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.UnaryOpNode -> applyTransposition(node.child).forEach { possibleNewTrees.add(node.copy(child = it)) }
            is FormulaNode.VariableNode -> {}
        }
        return possibleNewTrees.distinct()
    }
}
