// File: logic/RuleReplacer.kt
// This file contains the logic for applying replacement rules to a formula's syntax tree.

package com.elsoft.whatthewff.logic

import com.elsoft.whatthewff.logic.AvailableTiles.or
import com.elsoft.whatthewff.logic.AvailableTiles.and
import com.elsoft.whatthewff.logic.AvailableTiles.not
//import com.elsoft.whatthewff.logic.AvailableTiles.implies
//import com.elsoft.whatthewff.logic.AvailableTiles.iff
//import com.elsoft.whatthewff.logic.AvailableTiles.leftParen
//import com.elsoft.whatthewff.logic.AvailableTiles.rightParen

/**
 * A singleton object that handles the application of replacement rules.
 */
object RuleReplacer {

    /**
     * The main public function. It takes a syntax tree and a rule, and returns a list
     * of all possible new trees that can be generated by applying the rule at any
     * valid point within the original tree.
     *
     * @param rule The replacement rule to apply.
     * @param rootNode The root of the formula syntax tree to transform.
     * @return A list of new FormulaNode trees, each representing a valid transformation.
     */
    fun apply(rule: ReplacementRule, rootNode: FormulaNode): List<FormulaNode> {
        return when (rule) {
            ReplacementRule.DEMORGANS_THEOREM -> applyDeMorgans(rootNode)
            ReplacementRule.COMMUTATION -> applyCommutation(rootNode)
            ReplacementRule.ASSOCIATION -> TODO()
            ReplacementRule.DISTRIBUTION -> TODO()
            ReplacementRule.DOUBLE_NEGATION -> TODO()
            ReplacementRule.TRANSPOSITION -> TODO()
            ReplacementRule.MATERIAL_IMPLICATION -> TODO()
            ReplacementRule.MATERIAL_EQUIVALENCE -> TODO()
            ReplacementRule.EXPORTATION -> TODO()
            ReplacementRule.TAUTOLOGY -> TODO()
        }
    }

    /**
     * Recursively applies DeMorgan's Theorem to a given node and all its children.
     * Rule 1: ¬(P ∧ Q) ⇔ (¬P ∨ ¬Q)
     * Rule 2: ¬(P ∨ Q) ⇔ (¬P ∧ ¬Q)
     */
    private fun applyDeMorgans(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()

        // 1. Apply the rule at the CURRENT node, if possible.
        // This involves checking for all four possible patterns (both rules, both directions).

        // Form 1: ¬(P ∧ Q)  ->  (¬P ∨ ¬Q)
        if (node is FormulaNode.UnaryOpNode && node.operator.symbol == not.symbol &&
            node.child is FormulaNode.BinaryOpNode &&
            node.child.operator.symbol == and.symbol) {
                val innerAndNode = node.child
                val p = innerAndNode.left
                val q = innerAndNode.right
                val notP = FormulaNode.UnaryOpNode(not, p)
                val notQ = FormulaNode.UnaryOpNode(not, q)
                possibleNewTrees.add(FormulaNode.BinaryOpNode(or, notP, notQ))
        }

        // Form 2: (¬P ∨ ¬Q)  ->  ¬(P ∧ Q)
        if (node is FormulaNode.BinaryOpNode && node.operator.symbol == or.symbol &&
            node.left is FormulaNode.UnaryOpNode && node.left.operator.symbol == not.symbol &&
            node.right is FormulaNode.UnaryOpNode && node.right.operator.symbol == not.symbol) {
                val p = node.left.child
                val q = node.right.child
                val innerAndNode = FormulaNode.BinaryOpNode(and, p, q)
                possibleNewTrees.add(FormulaNode.UnaryOpNode(not, innerAndNode))
        }

        // Form 3: ¬(P ∨ Q)  ->  (¬P ∧ ¬Q)
        if (node is FormulaNode.UnaryOpNode && node.operator.symbol == not.symbol &&
            node.child is FormulaNode.BinaryOpNode && node.child.operator.symbol == or.symbol) {
                val innerOrNode = node.child
                val p = innerOrNode.left
                val q = innerOrNode.right
                val notP = FormulaNode.UnaryOpNode(not, p)
                val notQ = FormulaNode.UnaryOpNode(not, q)
                possibleNewTrees.add(FormulaNode.BinaryOpNode(and, notP, notQ))
        }

        // Form 4: (¬P ∧ ¬Q)  ->  ¬(P ∨ Q)
        if (node is FormulaNode.BinaryOpNode && node.operator.symbol == and.symbol &&
            node.left is FormulaNode.UnaryOpNode && node.left.operator.symbol == not.symbol &&
            node.right is FormulaNode.UnaryOpNode && node.right.operator.symbol == not.symbol) {
                val p = node.left.child
                val q = node.right.child
                val innerOrNode = FormulaNode.BinaryOpNode(or, p, q)
                possibleNewTrees.add(FormulaNode.UnaryOpNode(not, innerOrNode))
        }

        // 2. Recursively apply the rule to all CHILDREN nodes.
        when (node) {
            is FormulaNode.UnaryOpNode -> {
                applyDeMorgans(node.child).forEach { possibleNewTrees.add(node.copy(child = it)) }
            }
            is FormulaNode.BinaryOpNode -> {
                applyDeMorgans(node.left).forEach { possibleNewTrees.add(node.copy(left = it)) }
                applyDeMorgans(node.right).forEach { possibleNewTrees.add(node.copy(right = it)) }
            }
            is FormulaNode.VariableNode -> { /* No children to recurse into */ }
        }

        return possibleNewTrees
    }

    /**
     * Recursively applies the Commutation rule to a given node and all its children.
     * Commutation: (P ∧ Q) ⇔ (Q ∧ P)  and  (P ∨ Q) ⇔ (Q ∨ P)
     */
    private fun applyCommutation(node: FormulaNode): List<FormulaNode> {
        val possibleNewTrees = mutableListOf<FormulaNode>()

        // 1. Apply the rule at the CURRENT node, if possible.
        if (node is FormulaNode.BinaryOpNode &&
            (node.operator.symbol == and.symbol || node.operator.symbol == or.symbol)) {
            // Create the commuted version of this node by swapping left and right children.
            val commutedNode = node.copy(left = node.right, right = node.left)
            possibleNewTrees.add(commutedNode)
        }

        // 2. Recursively apply the rule to all CHILDREN nodes and
        //    rebuild the current node.  This is the key here.  We are
        //    iteratively building all the possible permutations of the
        //    parent node with all the possible permutations of the
        //    child nodes.
        when (node) {
            is FormulaNode.UnaryOpNode -> {
                // Get all possible transformations of the child.
                val childTransforms = applyCommutation(node.child)
                // For each transformed child, create a new version of the parent UnaryOpNode.
                childTransforms.forEach { txChild ->
                    possibleNewTrees.add(node.copy(child = txChild))
                }
            }
            is FormulaNode.BinaryOpNode -> {
                // Rebuild the node by recursively applying the rule to both children,
                // then hold one side the same as the original and create new possible
                // nodes with all the possible transformations of the other side.

                // Get all possible transformations of the left child.
                // Keep the right child the same as the original.
                applyCommutation(node.left).forEach { txLeft ->
                    possibleNewTrees.add(node.copy(left = txLeft))
                }

                // Get all possible transformations of the right child.
                // Keep the left child the same as the original.
                applyCommutation(node.right).forEach { txRight ->
                    possibleNewTrees.add(node.copy(right = txRight))
                }
            }
            is FormulaNode.VariableNode -> {
                // A variable has no children, so do nothing.
            }
        }

        return possibleNewTrees
    }
}
