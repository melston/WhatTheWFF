// File: test/com/elsoft/whatthewff/logic/RuleGeneratorsTest.kt
// This file contains unit tests for the RuleGenerators object.

package com.elsoft.whatthewff.logic

import com.elsoft.whatthewff.logic.AvailableTiles.or
import org.junit.Assert.*
import org.junit.Test

class RuleGeneratorsTest {

    // A helper function to easily create Formula objects from strings for testing.
    private fun f(formulaString: String): Formula {
        val tileMap = AvailableTiles.allTiles.associateBy { it.symbol }
        val tiles = formulaString.mapNotNull { char -> tileMap[char.toString()] }
        return Formula(tiles)
    }

    // A helper to make set comparisons in tests more readable.
    private fun assertFormulaSetsEqual(message: String, expected: Set<String>, actual: List<Formula>) {
        val actualStrings = actual.map { it.stringValue }.toSet()
        assertEquals(message, expected, actualStrings)
    }

    // ------------------ `canApply` tests ----------------------------------------

    @Test
    fun `modusPonens canApply is correct`() {
        val goal = f("(p→q)")
        val result = RuleGenerators.modusPonens.canApply(goal)
        assertFalse("MP should not apply to implication goals like '(p→q)'. Actual: $result", result)
    }

    @Test
    fun `conjunction canApply is correct`() {
        val goal = f("(p∨q)")
        val result = RuleGenerators.conjunction.canApply(goal)
        assertFalse("Conjunction should not apply to non-conjunction goals like '(p∨q)'. Actual: $result", result)
    }

    @Test
    fun `hypotheticalSyllogism canApply is correct`() {
        val goal = f("(p∨q)")
        val result = RuleGenerators.hypotheticalSyllogism.canApply(goal)
        assertFalse("HS should not apply to non-implication goals like '(p∨q)'. Actual: $result", result)
    }

    @Test
    fun `constructiveDilemma canApply is correct for disjunctions`() {
        val goal = f("(p∨q)") // A disjunction
        val result = RuleGenerators.constructiveDilemma.canApply(goal)
        assertTrue("Constructive Dilemma should apply to disjunctive goals like '(p∨q)'. Actual: $result", result)
    }

    @Test
    fun `constructiveDilemma canApply is false for non-disjunctions`() {
        val goal1 = f("(p→q)") // An implication
        val result1 = RuleGenerators.constructiveDilemma.canApply(goal1)
        assertFalse("Constructive Dilemma should not apply to non-disjunction goals like '(p→q)'. Actual: $result1", result1)

        val goal2 = f("p") // A single proposition
        val result2 = RuleGenerators.constructiveDilemma.canApply(goal2)
        assertFalse("Constructive Dilemma should not apply to single proposition goals like 'p'. Actual: $result2", result2)

        val goal3 = f("(p∧q)") // A conjunction
        val result3 = RuleGenerators.constructiveDilemma.canApply(goal3)
        assertFalse("Constructive Dilemma should not apply to conjunctive goals like '(p∧q)'. Actual: $result3", result3)
    }

    // Disjunctive Syllogism can always be applied.

    //----------------  `generate` tests ----------------------------------------
    // For testing generate functions we need to keep the following in mind.
    //
    // `generate` is a function that takes a goal formula and a list of available variables.
    // It returns a nullable GenerationStep object, which contains the new premises and
    // next goals.  If the generation strategy cannot be applied to the goal, this function
    // returns null.  This might happen, for example, if there are not enough available
    // variables to generate the next goal.
    //
    // And for the GenerationStep:
    // GenerationStep represents the output of one backward step of generation.
    // @property newPremises A list of new premises generated by the generation strategy.
    //           This is a list of formulas that are "finished." We add them directly to the
    //           final list of premises that the user will see.
    // @property nextGoals A list of potential next goals to continue the generation.
    //           This is a list of formulas that are not finished. We add them back into
    //           the goalsToSolve queue to be broken down further in subsequent steps of the
    //           generation.

    @Test
    fun `modusPonens strategy generates correct premise and next goal`() {
        val goal = f("q")
        val availableVars = mutableListOf(AvailableTiles.p)

        val step = RuleGenerators.modusPonens.generate(goal, availableVars)

        assertNotNull("Generation step should not be null", step)
        assertEquals("Should generate 1 new premise", 1, step!!.newPremises.size)
        assertEquals("Generated premise should be (p→q)", "(p→q)", step.newPremises.first().stringValue)
        assertEquals("Should generate 1 next goal", 1, step.nextGoals.size)
        assertEquals("Next goal should be p", "p", step.nextGoals.first().stringValue)
    }

    @Test
    fun `conjunction strategy generates correct sub-goals`() {
        val goal = f("(p∧q)")
        val availableVars = mutableListOf<LogicTile>() // Not needed for this rule

        val step = RuleGenerators.conjunction.generate(goal, availableVars)

        assertNotNull("Generation step should not be null", step)
        assertTrue("Should generate 0 new premises. Actual: ${step!!.newPremises.map { it.stringValue }}", step.newPremises.isEmpty())
        assertFormulaSetsEqual(
            "Next goals for (p∧q) should be p and q.",
            expected = setOf("p", "q"),
            actual = step.nextGoals
        )
    }

    @Test
    fun `hypotheticalSyllogism strategy generates correct sub-goals`() {
        val goal = f("(p→r)")
        val availableVars = mutableListOf(AvailableTiles.q) // The intermediate variable

        val step = RuleGenerators.hypotheticalSyllogism.generate(goal, availableVars)

        assertNotNull("Generation step should not be null", step)
        assertTrue("Should generate 0 new premises. Actual: ${step!!.newPremises.map { it.stringValue }}", step.newPremises.isEmpty())
        assertFormulaSetsEqual(
            "Next goals for (p→r) should be (p→q) and (q→r).",
            expected = setOf("(p→q)", "(q→r)"),
            actual = step.nextGoals
        )
    }

    @Test
    fun `constructiveDilemma strategy generates correct new premises`() {
        // Goal: (q∨s)
        // We need P and R from availableVars. Let's say P is 'p' and R is 'r'.
        // Expected new premises: ((p→q)∧(r→s)) and (p∨r)
        val goal = f("(q∨s)")
        val availableVars = mutableListOf(
            AvailableTiles.p, // This will be used for P
            AvailableTiles.r  // This will be used for R
        )

        val step = RuleGenerators.constructiveDilemma.generate(goal, availableVars)

        assertNotNull("Generation step should not be null for Constructive Dilemma", step)
        assertTrue(
            "Should generate 0 new premises. Actual: ${step!!.newPremises.map { it.stringValue }}",
            step.newPremises.isEmpty()
        )
        assertEquals(
            "Should generate 2 new goals. Actual: ${step.nextGoals.map { it.stringValue }}",
            2,
            step.nextGoals.size
        )

        val expectedNextGoals = setOf("((p→q)∧(r→s))", "(p∨r)")
        assertFormulaSetsEqual(
            "Next goals are incorrect.",
            expected = expectedNextGoals,
            actual = step.nextGoals
        )
    }

    @Test
    fun `disjunctiveSyllogism strategy generates correct premise and next goal`() {
        val goal = f("q")
        val availableVars = mutableListOf(AvailableTiles.p)

        val step = RuleGenerators.disjunctiveSyllogism.generate(goal, availableVars)

        assertNotNull("Generation step should not be null", step)
        assertEquals("Should generate 1 new premise", 1, step!!.newPremises.size)
        assertEquals("Generated premise should be (p∨q)", "(p∨q)", step.newPremises.first().stringValue)
        assertEquals("Should generate 1 next goal", 1, step.nextGoals.size)
        assertEquals("Next goal should be ¬p", "¬p", step.nextGoals.first().stringValue)
    }
}
